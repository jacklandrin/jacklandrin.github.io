---
layout: post
title: "Talking about Aspect Oriented Programming in iOS"
date: "2018-05-15"
excerpt: The Apsect Oriented Programming (AOP) is usually used in backend development. But it's more and more popular in clients programming recent days.
categories: 
  - "programming"
tags:
  - "Objective-C"
  - "programming"
---

## 1\. What's the Aspect Oriented Programming?

The **Apsect Oriented Programming** (AOP) is usually used in backend development. But it's more and more popular in clients programming recent days.

You can find out the definition in [Wikipedia](https://en.wikipedia.org/wiki/Aspect-oriented_programming):

> In computing, AOP is a programming paradigm that aims to increase modularity by allowing the separation of cross-cutting concerns. It does so by adding additional behavior to existing code (an advice) without modifying the code itself, instead separately specifying which code is modified via a "pointcut" specification, such as "log all function calls when the function's name begins with 'set'". This allows behaviors that are not central to the business logic (such as logging) to be added to a program without cluttering the code, core to the functionality. AOP forms a basis for aspect-oriented software development.

## 2\. How to implement AOP in iOS？

When we develop a statistic system of client, sometimes we don't want add any code to the business logic. AOP is a good choice for some situation of logging. We can hook methods in which we need to make some logs. Such as logging page appear and disappear.

### Method Swizzling

In iOS programming, we can implement AOP by **Method Swizzling**. Method Swizzling is way that replace original method with another.

![](/assets/img/images/1453346875560481.png)

![](/assets/img/images/1453346881610109.png)

Talking about some Runtime knowledge is necessary to how to explain Method Swizzling. Method in Objective-C consists of **SEL(Selector)** and **IMP(implemention)**.

- [Method selectors](https://developer.apple.com/documentation/objectivec/sel) are used to represent the name of a method at runtime. A method selector is a C string that has been registered (or “mapped“) with the Objective-C runtime. Selectors generated by the compiler are automatically mapped by the runtime when the class is loaded.
- [IMP](https://developer.apple.com/documentation/objectivec/objective_c_runtime/imp?language=objc) is a pointer to the start of the function that implements the method.

Method Swizzling exchanges IMPs mapped selectors in order to replace methods. Implementing a Method Swizzling, the core C language API at runtime is:

```
OBJC_EXPORT void method_exchangeImplementations(Method m1, Method m2) 
 __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

```

### Method Swizzling Example

Suppose we want to print out a log statement whenever _\-viewDidLoad()_ is called on a _UIViewController_. Creating a category of UIViewController, and implement its _+load()_.

```
#import "UIViewController+swizzling.h"
#import @implementation UIViewController (swizzling)

+ (void)load {
    [super load];
    // class_getInstanceMethod() get method structure from method list
    Method fromMethod = class_getInstanceMethod([self class], @selector(viewDidLoad));
    Method toMethod = class_getInstanceMethod([self class], @selector(swizzling_ViewDidLoad));

    if (!class_addMethod([self class], @selector(viewDidLoad), method_getImplementation(toMethod), method_getTypeEncoding(toMethod))) {
        method_exchangeImplementations(fromMethod, toMethod);
    }
}

//  define method by myself, replacing original method
- (void)swizzling_ViewDidLoad {
    NSLog(@"Log something... for %@",[self class]);
    [self swizzling_ViewDidLoad];
}
@end
```

## 3\. Aspects

Obviously, if we use this way to hook every method needed to add log, it will be a huge project. Maybe there is a third party libarary that we use easier. YES, [Aspects](https://github.com/steipete/Aspects) is an awesome tool for AOP in Objective-C.

Aspects provides two methods for developer:

```
+ (id<AspectToken>)aspect_hookSelector:(SEL)selector
                      withOptions:(AspectOptions)options
                       usingBlock:(id)block
                            error:(NSError **)error;
```

```
- (id<AspectToken>)aspect_hookSelector:(SEL)selector
                      withOptions:(AspectOptions)options
                       usingBlock:(id)block
                            error:(NSError **)error;
```

An instance method and a class method, they have same name and same parameters. It's thread safe for all invoking, and Aspects makes some perfermance loss due to message passing of Objective-C. Therefore I don't suggest use Aspects for methods in frequent invoked.

### Example

I use the Aspects instead of complex Method Swizzling, hook _\-viewWillApear()_ in all _UIViewControllers_.

```
#import "ViewControllerLogger.h"
#import @implementation ViewControllerLogger

- (instancetype)init {
    if (self = [super init]) {
        [UIViewController aspect_hookSelector:@selector(viewWillAppear:) withOptions:AspectPositionAfter usingBlock:^(id<AspectInfo> aspectInfo) {
            NSLog(@"ViewController will appear:--> %@", NSStringFromClass([aspectInfo.instance class]));
        } error:NULL];
    }
}
@end
```

### Disadvantage

There are some disadvantages at Aspects.

- Perfermance lossI have memtioned that above paragraph.
- Can't hook class method
    
    If you hook a class method, the block won't callback and you'll get failure said **Aspects: Block signature doesn't match (null)**. The reason is that runtime just obtain member method list, if you want to get class method, you must get it from **MetaClass** of this class. You can get MetaClass by _object\_getClass(newClass)_.
    
    Fortunately, there is a gay coding a function for class method hooking:
    
    ```
    static void aspect_prepareClassAndHookSelector(NSObject *self, SEL selector, NSError **error) {
    NSCParameterAssert(selector);
    Class klass = aspect_hookClass(self, error);
    //TODO:Edit by JackYong
    Method targetMethod;
    IMP targetMethodIMP;
    if (class_isMetaClass(klass)) {
        targetMethod = class_getClassMethod(klass, selector);
        targetMethodIMP = method_getImplementation(targetMethod);
    } else {
        targetMethod = class_getInstanceMethod(klass, selector);
        targetMethodIMP = method_getImplementation(targetMethod);
    }
    ```
